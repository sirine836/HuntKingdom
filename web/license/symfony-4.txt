Symfony3 est un framework, autrement dit : une boite à outils. qui va vous permettre de réaliser des sites complexes rapidement,
 mais de façon structurée et avec un code clair et maintenable



app - les configurations, vues et les assets globales (jquery, boostrap,...);c. Ce sont des fichiers qui concernent l'entièreté
de votre site contrairement aux fichiers de code source qui seront découpés par fonctionnalité de votre site.

bin - les scripts de gestion symfony 3;
src - les bundles de votre projet;
var - les logs et le dossier de cache;
vendor - les bundles (vendors) externes;
web - les fichiers "publics" de votre projet.

Command : Les commandes ou tâches vous permettent d’effectuer des traitements sur votre projet qui sont exécutés 
directement en ligne de commande. Souvent utilisé pour mettre en place des routines (maintenance de la base de données, 
système de notification...), vous ne devez pas oublier que n'avez pas de contexte lors de l’exécution 
de ces scripts et donc pas d'accès "request" par exemple.

Controller : Le controller contient les routers de votre application qui réalise le pont entre
 la "request" HTTP et la "response" HTTP renvoyée.

Le contrôleur frontal est le point d'entrée de votre application  C'est le fichier par lequel passent toutes vos pages.(app_dev.php.,app.php(visiteur))

DataFixtures : Stocke les fixtures du projet (jeu de données).

Entity : Les déclarations de vos entités.

Repository : Les Repository gèrent les requêtes DQL ou SQL liées aux entités.

Listener : Les Listeners vous permettent d'exécuter du code lors d'un événement du déroulement des pages.

Form : Les formulaires de votre projet.

Manager : Le code métier ou des traitements spécifiques. Les managers permettent de centraliser
 du code qui pourrait être appelé par plusieurs controllers par exemple.


MVC signifie « Modèle / Vue / Contrôleur ».  il sépare les couches selon leur logique propre :
Le Contrôleur  contient la logique de notre site Internet et va se contenter « d'utiliser » les autres composants : les modèles et les vue.
Le Modèle (ou Model) : son rôle est de gérer vos données et votre contenu.  il permet au contrôleur de manipuler les articles, 
mais sans savoir comment les articles sont stockés, gérés, etc. C'est une couche d'abstraction.
La Vue (ou View) : son rôle est d'afficher les pages.


Un bundle est une brique de votre application : il contient tout ce qui concerne une fonctionnalité donnée. Cela permet de bien organiser les différentes 
parties de votre site.

appKernel : les bundles à charger pour l'environnement de production et les bundles à charger en plus pour l'environnement de développement.

routing : 


Symfony intègre un système de routing permettant d'interpréter une URL et en déduire l'action et donc la page à afficher. 
C'est un système très puissant qui nous permettra de gérer tous les liens internes du projet. 
Le routing nous permet aussi de gérer facilement des URLs plus parlantes et de savoir à quelle action et donnée elle correspond. (URL rewriting etc.) 

il ya 2 type de routing : routing general =># app/config/routing.yml
                                    routing du bundle => les annotations juste au dessus de l'action du controlleur

* @Route("/hello/{name}") route avec un paramétre 
* @Route("/", name="homepage") route qui ne prend pas de paramétre 

Dans une action, il faut toujours renvoyer une réponse avec l'objet Symfony\Component\HttpFoundation\Response 
exemple UpdateCartAction(request $req)
{
return **** (retourner une reponse ); 
} 

Twig est un moteur de template PHP  directement intégré dans Symfony2.Twig permettra de gérer de l'héritage entre templates et layout,
 séparer les couches de présentation et couches métiers... 


*@ORM\Table(name="desk") : une entité doctrine et qu'il faut donc la lier à une table de notre BDD. 

* @ORM\Entity(repositoryClass="Wmd\WatchMyDeskBundle\Entity\DeskRepository"): L'annotation suivante @ORM\Entity(repositoryClass, permet de définir 
la classe de Repository à lier avec l'entité. Une Repository class stocke toutes les requêtes Doctrine ou autre pour bien séparer les couches. 

*@ORM\Column(name="title", type="string", length=255) Toutes nos propriétés sont en private et décrites avec l'annotation ORM Columns:
C'est grâce à ces définitions que nous allons pouvoir générer notre base de données.  
*@var integer $id ;
@ORM\Id 
* @ORM\GeneratedValue(strategy="AUTO") clé auto increment
definir aprés un constructeur pour initialisé nos objet 

Les entités ne sont que de simples classes liées à la BDD via l'ORM Doctrine. 
.
$em = $this->getDoctrine()->getEntityManager(); Initialisez l'entity manager 
$em->persist($desk); Persistez l'objet dans l'entity manager 
$em->flush();  On flush l'entity manager pour que les données soient insérées ou mises à jour en BDD 

Repository : Ce dernier va nous permettre de stocker et séparer les appels en BDD, la création des requêtes dbal / dql .Pour faire simple, on va dire que tout ce qui touche les requêtes en base de données devra se situer dans les repository. 
C'est à cet endroit que l'on va construire nos requêtes doctrine grâce au queryBuilder. 
 la méthode createQuery de l'entity manager Créer des requête   en récupérant l'entity manager stockée dans la propriété _em de la classe(utilise mysquel)
 le queryBuilder doctrine: 

Pour faciliter la gestion de nos entités, nous allons centraliser les actions dans des Managers.  ils permettront aussi de manipuler plus facilement 
nos entités en faisant le lien entre les repository et l'entité,



